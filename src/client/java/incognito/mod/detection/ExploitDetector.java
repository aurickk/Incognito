package incognito.mod.detection;

import incognito.mod.Incognito;
import incognito.mod.PrivacyLogger;
import incognito.mod.config.IncognitoConstants;

import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Detects and tracks translation key exploits from various sources (signs, anvils, books).
 * Uses stack trace analysis and player interaction timing to identify exploit attempts.
 */
public class ExploitDetector {
    
    private static final Set<String> SIGN_CLASSES = Set.of(
        "class_498", "class_7743", "class_3876", "class_496", "class_7568"
    );
    
    private static final Set<String> ANVIL_CLASSES = Set.of(
        "class_471", "class_1706"
    );
    
    private static final Set<String> BOOK_CLASSES = Set.of(
        "class_475", "class_477", "class_5503"
    );
    public static PrivacyLogger.ExploitSource detectSource() {
        StackTraceElement[] stack = Thread.currentThread().getStackTrace();
        
        for (StackTraceElement element : stack) {
            String className = element.getClassName();
            String classNameLower = className.toLowerCase();
            String methodName = element.getMethodName().toLowerCase();
            
            if (classNameLower.contains("sign") || classNameLower.contains("signtext") || 
                classNameLower.contains("signblock") || methodName.contains("sign")) {
                return PrivacyLogger.ExploitSource.SIGN;
            }
            if (classNameLower.contains("anvil") || methodName.contains("anvil")) {
                return PrivacyLogger.ExploitSource.ANVIL;
            }
            if (classNameLower.contains("book") || classNameLower.contains("lectern") ||
                methodName.contains("book") || methodName.contains("lectern")) {
                return PrivacyLogger.ExploitSource.BOOK;
            }
            
            if (className.startsWith("net.minecraft.class_")) {
                String classId = className.substring(className.lastIndexOf('.') + 1);
                
                if (SIGN_CLASSES.contains(classId)) return PrivacyLogger.ExploitSource.SIGN;
                if (ANVIL_CLASSES.contains(classId)) return PrivacyLogger.ExploitSource.ANVIL;
                if (BOOK_CLASSES.contains(classId)) return PrivacyLogger.ExploitSource.BOOK;
            }
        }
        
        // If we can't detect the source but player recently interacted with something,
        // use that as a hint
        if (wasSignPlayerInitiated()) {
            return PrivacyLogger.ExploitSource.SIGN;
        }
        if (wasAnvilPlayerInitiated()) {
            return PrivacyLogger.ExploitSource.ANVIL;
        }
        
        return PrivacyLogger.ExploitSource.UNKNOWN;
    }
    
    private static volatile long lastPlayerSignInteraction = 0;
    private static volatile long lastPlayerAnvilInteraction = 0;
    
    public static void markSignInteraction() {
        lastPlayerSignInteraction = System.currentTimeMillis();
        Incognito.LOGGER.debug("[ExploitDetector] Player sign interaction marked");
    }
    
    public static void markAnvilInteraction() {
        lastPlayerAnvilInteraction = System.currentTimeMillis();
        Incognito.LOGGER.debug("[ExploitDetector] Player anvil interaction marked");
    }
    
    public static boolean wasSignPlayerInitiated() {
        return (System.currentTimeMillis() - lastPlayerSignInteraction) < IncognitoConstants.Timeouts.INTERACTION_TIMEOUT_MS;
    }
    
    public static boolean wasAnvilPlayerInitiated() {
        return (System.currentTimeMillis() - lastPlayerAnvilInteraction) < IncognitoConstants.Timeouts.INTERACTION_TIMEOUT_MS;
    }
    
    public static boolean wasPlayerInitiated(PrivacyLogger.ExploitSource source) {
        return switch (source) {
            case SIGN -> wasSignPlayerInitiated();
            case ANVIL -> wasAnvilPlayerInitiated();
            default -> false;
        };
    }
    
    private static final Set<String> alertedItems = ConcurrentHashMap.newKeySet();
    private static volatile long lastDedupeResetTime = 0;
    private static volatile long lastAlertTime = 0;
    
    public static boolean shouldAlert(String alertKey) {
        long now = System.currentTimeMillis();
        
        if (now - lastDedupeResetTime > IncognitoConstants.Timeouts.ALERT_COOLDOWN_MS) {
            alertedItems.clear();
            lastDedupeResetTime = now;
        }
        
        return alertedItems.add(alertKey);
    }
    
    public static boolean shouldSendHeaderAlert() {
        long now = System.currentTimeMillis();
        if (now - lastAlertTime >= IncognitoConstants.Timeouts.ALERT_COOLDOWN_MS) {
            lastAlertTime = now;
            return true;
        }
        return false;
    }
    
    public static void reset() {
        lastPlayerSignInteraction = 0;
        lastPlayerAnvilInteraction = 0;
        alertedItems.clear();
        lastDedupeResetTime = 0;
        lastAlertTime = 0;
    }
}

